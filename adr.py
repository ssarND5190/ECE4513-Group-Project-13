import numpy as np
import cvxpy as cp
import matplotlib.pyplot as plt

# 数据 x (特征矩阵)
x = np.array([
    [0.1129, 2.0654],
    [2.2321, 2.4077],
    [1.2010, 1.7391],
    [0.8020, 1.8637],
    [-1.6023, 2.5203],
    [1.3414, 0.2834],
    [-0.2115, 2.8215],
    [-1.3472, -0.2216],
    [1.4618, 1.1345],
    [1.5988, 0.2905],
    [0.5065, 2.3197],
    [1.7832, 2.6186],
    [1.0766, 1.6960],
    [0.6610, 2.6356],
    [0.8240, 2.5577],
    [0.9630, -0.9756],
    [2.4884, 1.1639],
    [3.0923, 4.0526],
    [-0.3804, 2.2341],
    [4.3589, 1.7161],
    [1.6517, 2.4377],
    [2.8132, 3.4426],
    [-0.1657, 1.4199],
    [1.3140, 1.9227],
    [3.7543, 2.5803],
    [1.0187, 0.8919],
    [0.0896, 3.0506],
    [1.1273, 2.8587],
    [0.6165, 3.1852],
    [-0.0301, 4.0725],
    [1.9016, 2.1457],
    [-0.3599, 1.4741],
    [1.8582, 3.5978],
    [0.6140, 3.7133],
    [3.5204, 1.3447],
    [1.1401, 1.1305],
    [0.0183, 3.9453],
    [1.4388, 1.3244],
    [0.9985, 1.6960],
    [-1.9029, -1.8130],
    [0.7213, 1.3882],
    [0.0004, 0.8809],
    [-1.0781, 1.3098],
    [0.6305, 0.5954],
    [1.3141, 1.6391],
    [0.1840, 0.1095],
    [0.4407, 2.5426],
    [0.2909, 2.2138],
    [3.3755, 3.0520],
    [3.2175, 5.1224],
    [3.3743, 0.5262],
    [3.4989, -1.1967],
    [2.3270, 2.6699],
    [2.4333, -0.0557],
    [2.3261, -0.3494],
    [1.5146, -0.5117],
    [0.9741, -1.2484],
    [1.6528, -0.7602],
    [3.5596, 0.3116],
    [2.9515, -0.1850],
    [2.5476, 1.6645],
    [3.4850, 0.0436],
    [3.9303, 0.6293],
    [3.4645, 2.8997],
    [3.9893, 1.2002],
    [2.1331, -0.7122],
    [2.7958, 2.4103],
    [-0.3400, -0.8426],
    [1.8853, 0.1961],
    [0.4807, 0.6999],
    [2.2597, -1.2437],
    [1.1339, -1.6054],
    [3.8113, 0.4941],
    [1.2864, -1.2243],
    [2.9408, 2.2281],
    [2.4519, 0.4674],
    [0.8827, 0.2198],
    [2.0854, -1.8275],
    [4.3610, 3.2615],
    [-0.5912, -2.7339],
    [2.3070, 1.0042],
    [1.8391, -0.2096],
    [1.4742, -1.4083],
    [1.1469, 2.0922],
    [1.6988, -1.5711],
    [2.4273, -1.7163],
    [2.2486, 0.9799],
    [0.9845, -0.4623],
    [3.0058, 2.5827],
    [2.2594, -0.5282],
    [1.6345, -0.3708],
    [3.1645, -0.3762],
    [1.3286, 0.3183],
    [2.3020, 1.0494],
    [3.5030, 1.4381],
    [2.9634, 0.8368],
    [3.3233, -1.5346],
    [0.8052, -2.2424],
    [2.9302, 0.0285],
    [0.8402, -2.2767]
])

# 数据 y (标签)
y = np.array([
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
])

# 获取样本数 N 和特征维度 n_features
N, n_features = x.shape

# 定义变量
beta = cp.Variable(n_features + 1)  # beta_0 + beta_1 ~ beta_n
t = cp.Variable(N)

# 构造目标函数：最小化总误差
objective = cp.Minimize(cp.sum(t))

# 构造约束条件
constraints = []
for i in range(N):
    y_hat = beta[0] + x[i, :] @ beta[1:]
    constraints += [
        t[i] >= y[i] - y_hat,
        t[i] >= -(y[i] - y_hat)
    ]

# 求解问题
problem = cp.Problem(objective, constraints)
problem.solve()

# 输出最优 beta 值
print("最优 beta 值：", beta.value)

# 可视化分类边界
beta_opt = beta.value

# 分离两类数据
class0 = x[y == 0]
class1 = x[y == 1]

# 绘制数据点
plt.scatter(class0[:, 0], class0[:, 1], c='blue', label='Class 0')
plt.scatter(class1[:, 0], class1[:, 1], c='red', label='Class 1')

# 构造决策边界线
# 绘制决策边界
if n_features == 2:  
    x1_vals = np.linspace(np.min(x[:, 0]), np.max(x[:, 0]), 100)
    # 修改此处，使决策边界为 β0 + β1*x1 + β2*x2 = 0.5
    x2_vals = (0.5 - beta.value[0] - beta.value[1] * x1_vals) / beta.value[2]
    plt.plot(x1_vals, x2_vals, 'k-', label='Decision Boundary')

# 设置图例和坐标轴标签
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.title('ADR Decision Boundary')
plt.legend()
plt.grid(True)
plt.show()